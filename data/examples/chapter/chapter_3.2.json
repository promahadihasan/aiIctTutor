{
  "topics": [
    {
      "id": 1,
      "name": "বুলিয়ান অ্যালজেবরা",
      "definition": "বুলিয়ান অ্যালজেবরা হলো এমন একটি গাণিতিক শাখা যা **যৌক্তিক যুক্তি (Logical Reasoning)** বিশ্লেষণ এবং প্রকাশের জন্য ব্যবহৃত হয়। এটি কেবলমাত্র দুটি বাইনারি মান নিয়ে কাজ করে: **সত্য (True) বা ১** এবং **মিথ্যা (False) বা ০**। \n এই অ্যালজেবরায় তিনটি মৌলিক প্রক্রিয়া \n রয়েছে: **লজিক্যাল অ্যাডিশন (+, OR), লজিক্যাল মাল্টিপ্লিকেশন (*, AND)** এবং **লজিক্যাল কমপ্লিমেন্টেশন (', NOT)**। এটি আধুনিক কম্পিউটার ও ডিজিটাল সার্কিট ডিজাইনের গাণিতিক ভিত্তি হিসেবে কাজ করে।"
    },
    {
      "id": 2,
      "name": "বুলিয়ান মৌলিক উপপাদ্য সমূহ",
      "definition": "বুলিয়ান অ্যালজেবরায় ব্যবহৃত মৌলিক উপপাদ্যসমূহ হলো সেই গাণিতিক নিয়মাবলী যা বুলিয়ান রাশিমালাকে সরলীকরণ (Simplification) করতে সাহায্য করে। এই উপপাদ্যগুলো প্রধানত তিনটি মৌলিক অপারেশনের উপর ভিত্তি করে তৈরি। যেমন: \n ১. OR অপারেশন:\n A+0 = A, A+1 = 1, A+A = A, A+A' = 1; \n ২. AND অপারেশন:\n A * 1 = A, A * 0 = 0, A * A = A, A * A' = 0; এবং \n ৩. দ্বৈত পরিপূরক (Double Complement):\n (A')' = A, \n ৪. অ্যাসোসিয়েটিভ, কমিউটেটিভ ও ডিস্ট্রিবিউটিভ নীতিসমূহ\n (যেমন: A * (B+C) = A*B + A*C)।"
    },
    {
      "id": 3,
      "name": "ডি- মরগান উপপাদ্য ও সত্যক সারণি দিয়ে প্রমাণ",
      "definition": "ডি-মরগান উপপাদ্য (De Morgan's Theorem) বুলিয়ান অ্যালজেবরার দুটি মৌলিক ও অত্যন্ত গুরুত্বপূর্ণ সূত্র যা জটিল বুলিয়ান রাশিমালাকে সরল করতে ব্যবহৃত হয়। \nসূত্র দুটি হলো:\n ১. দুটি চলকের লজিক্যাল যোগফলের পরিপূরক তাদের প্রত্যেকের পরিপূরকের লজিক্যাল গুণফলের সমান: \n(A+B)' = A' * B'\n এবং \n ২. দুটি চলকের লজিক্যাল গুণফলের পরিপূরক তাদের প্রত্যেকের পরিপূরকের লজিক্যাল যোগফলের সমান: \n(A * B)' = A' + B'\n \n সত্যক সারণি (Truth Table) ব্যবহার করে প্রতিটি ইনপুট কম্বিনেশনের জন্য বামপক্ষ (LHS) এবং ডানপক্ষ (RHS) এর মান সমান দেখিয়ে এই উপপাদ্য প্রমাণ করা হয়।"
    },
    {
      "id": 4,
      "name": "লজিক গেট",
      "definition": "লজিক গেট হলো ডিজিটাল ইলেকট্রনিক সার্কিটের **মৌলিক বিল্ডিং ব্লক**, যা বুলিয়ান অ্যালজেবরার নীতি অনুসারে এক বা একাধিক ইনপুট গ্রহণ করে এবং একটি সুনির্দিষ্ট লজিক অপারেশন সম্পন্ন করার পর একটি মাত্র আউটপুট প্রদান করে। এই গেটগুলো প্রধানত **ট্রানজিস্টর** ব্যবহার করে তৈরি করা হয় এবং কম্পিউটারের অভ্যন্তরীণ সকল গাণিতিক ও যৌক্তিক প্রক্রিয়াকরণের জন্য অপরিহার্য। লজিক গেট মূলত তিন প্রকার: **মৌলিক গেট, সার্বজনীন গেট এবং এক্সক্লুসিভ গেট**।"
    },
    {
      "id": 5,
      "name": "মৌলিক লজিক গেট",
      "definition": "যেসব লজিক গেট ব্যবহার করে অন্যান্য সকল ধরনের লজিক গেট ও ডিজিটাল সার্কিট তৈরি করা যায়, সেগুলোকে **মৌলিক লজিক গেট (Basic Logic Gates)** বলে। মৌলিক গেট তিনটি: **১. OR গেট** (যোগের নীতি অনুসরণ করে), **২. AND গেট** (গুণের নীতি অনুসরণ করে), এবং **৩. NOT গেট** (ইনপুটকে পরিপূরক বা উল্টে দেয়)। এই তিনটি গেটই বুলিয়ান অ্যালজেবরার তিনটি মৌলিক অপারেশনকে সরাসরি বাস্তবায়ন করে।"
    },
    {
      "id": 6,
      "name": "সার্বজনীন গেট",
      "definition": "যেসব লজিক গেট ব্যবহার করে **এককভাবে** মৌলিক গেটসহ (OR, AND, NOT) অন্য যেকোনো জটিল লজিক গেট বা ডিজিটাল সার্কিট ডিজাইন ও বাস্তবায়ন করা যায়, সেগুলোকে **সার্বজনীন গেট (Universal Gates)** বলে। এদেরকে ইউনিভার্সাল গেট বলার কারণ হলো, শুধুমাত্র এই গেটগুলি ব্যবহার করেই যেকোনো বুলিয়ান ফাংশন তৈরি করা সম্ভব। সার্বজনীন গেট দুটি: **১. NAND গেট** (AND + NOT) এবং **২. NOR গেট** (OR + NOT)।"
    },
    {
      "id": 7,
      "name": "এক্সক্লুসিভ গেট",
      "definition": "এক্সক্লুসিভ গেট (Exclusive Gates) হলো বিশেষ ধরনের লজিক গেট যা তুলনামূলক অপারেশন এবং ডিজিটাল এনকোডিং-এর ক্ষেত্রে ব্যবহৃত হয়। এদের আউটপুট ইনপুটগুলোর মানের **নির্দিষ্ট সমতা বা অসমতার** উপর নির্ভরশীল। এক্সক্লুসিভ গেট দুটি: **১. এক্স-অর গেট (Ex-OR/XOR)**, যার আউটপুট ১ হয় যখন ইনপুটগুলি **অসমান** হয় ($Y = A \\oplus B$); এবং **২. এক্স-নোর গেট (Ex-NOR/XNOR)**, যার আউটপুট ১ হয় যখন ইনপুটগুলি **সমান** হয় ($Y = (A \\oplus B)'$)। এই গেটগুলো অ্যাডার সার্কিটে বিশেষভাবে ব্যবহৃত হয়।"
    },
    {
      "id": 8,
      "name": "এনকোডার কি?",
      "definition": "এনকোডার (Encoder) হলো এমন একটি কম্বিনেশনাল লজিক সার্কিট যা **মানুষের বোধগম্য তথ্য** (যেমন— ডেসিমাল সংখ্যা বা একটি কীবোর্ডের চাপ) গ্রহণ করে এবং তাকে কম্পিউটারের বোধগম্য **বাইনারি বা কোডেড ফর্মে (যেমন: BCD)** রূপান্তর করে। সাধারণত এটি $2^n$ সংখ্যক ইনপুট লাইন থেকে $n$ সংখ্যক আউটপুট লাইন তৈরি করে। এনকোডার ইনপুটগুলিকে কোডে রূপান্তর করে ডেটা সঞ্চয় এবং যোগাযোগের জন্য প্রস্তুত করে।"
    },
    {
      "id": 9,
      "name": "ডিকোডার কি",
      "definition": "ডিকোডার (Decoder) হলো এমন একটি কম্বিনেশনাল লজিক সার্কিট যা এনকোডারের ঠিক **বিপরীত কাজ** করে। এটি একটি $n$ সংখ্যক বাইনারি ইনপুট কোড গ্রহণ করে এবং এটিকে সর্বোচ্চ $2^n$ সংখ্যক স্বতন্ত্র আউটপুট লাইনে রূপান্তর করে। অর্থাৎ, এটি **বাইনারি কোডকে** (যেমন: CPU থেকে আসা ঠিকানা বা নির্দেশ) আবার মানুষের বোধগম্য ফর্মে বা ডিভাইসের কার্যকর করার উপযোগী রূপে (যেমন— ডিসপ্লেতে দেখানো বা মেমরি অবস্থান নির্বাচন করা) রূপান্তর করে।"
    },
    {
      "id": 10,
      "name": "অ্যাডার",
      "definition": "অ্যাডার (Adder) হলো একটি কম্বিনেশনাল লজিক সার্কিট যা বাইনারি সংখ্যায় **যোগ (Addition)** অপারেশন সম্পন্ন করার জন্য ডিজাইন করা হয়েছে। ডিজিটাল কম্পিউটার এবং ক্যালকুলেটরে সকল গাণিতিক অপারেশন (যোগ, বিয়োগ, গুণ, ভাগ) সম্পন্ন করার জন্য অ্যাডার সার্কিট অপরিহার্য। অ্যাডার প্রধানত দুই প্রকার: **হাফ অ্যাডার (Half Adder)**, যা দুটি বিট যোগ করে, এবং **ফুল অ্যাডার (Full Adder)**, যা ক্যারি-ইনসহ তিনটি বিট যোগ করতে সক্ষম।"
    },
    {
      "id": 11,
      "name": "হাফ অ্যাডার ও ফুল অ্যাডার এর পার্থক্য",
      "definition": "হাফ অ্যাডার ও ফুল অ্যাডার উভয়েই বাইনারি যোগের জন্য ব্যবহৃত হলেও তাদের ইনপুট সংখ্যায় পার্থক্য রয়েছে। **হাফ অ্যাডার (Half Adder)** দুটি ইনপুট বিট যোগ করে দুটি আউটপুট (Sum এবং Carry Out) তৈরি করে। এটি কেবল প্রথম ধাপের যোগের জন্য উপযুক্ত। অন্যদিকে, **ফুল অ্যাডার (Full Adder)** তিনটি ইনপুট বিট (দুটি ডেটা বিট এবং একটি পূর্ববর্তী ধাপের ক্যারি ইন, $C_{in}$) যোগ করে দুটি আউটপুট (Sum এবং Carry Out) তৈরি করে। এটি একাধিক বিটের যোগের ক্ষেত্রে ক্যারি-কে বিবেচনা করতে সক্ষম হওয়ায়, এটি বহুল-বিট যোগের জন্য উপযুক্ত।"
    },
    {
      "id": 12,
      "name": "ফ্লিপ ফ্লপ",
      "definition": "ফ্লিপ ফ্লপ (Flip-Flop) হলো একটি মৌলিক **সিকোয়েন্সিয়াল লজিক সার্কিট** যা **এক বিট বাইনারি ডেটা** (০ বা ১) অস্থায়ীভাবে সংরক্ষণ করতে সক্ষম। এটি একটি স্মৃতি উপাদান (Memory Element) হিসেবে কাজ করে এবং এটির আউটপুট শুধুমাত্র বর্তমান ইনপুটের উপর নির্ভর করে না, বরং পূর্ববর্তী অবস্থার (Previous State) উপরও নির্ভর করে। ফ্লিপ ফ্লপগুলো সাধারণত একটি **ক্লক পালস (Clock Pulse)** দ্বারা নিয়ন্ত্রিত হয়। ফ্লিপ ফ্লপ বিভিন্ন প্রকারের হতে পারে, যেমন: SR, JK, D, এবং T ফ্লিপ ফ্লপ।"
    },
    {
      "id": 13,
      "name": "লেচ",
      "definition": "লেচ (Latch) হলো ফ্লিপ ফ্লপের মতোই এক বিট ডেটা সংরক্ষণকারী একটি মৌলিক **সিকোয়েন্সিয়াল লজিক সার্কিট**, কিন্তু ফ্লিপ ফ্লপের বিপরীতে, এটি **ক্লক পালসের লেভেল (Level)** দ্বারা নিয়ন্ত্রিত হয়, ক্লকের এজ (Edge) দ্বারা নয়। লেচ যখন এনাবল্ড (Enabled) থাকে, তখন তার আউটপুট ইনপুট পরিবর্তনের সাথে সাথেই পরিবর্তিত হয় (একে 'ট্রান্সপারেন্ট' বলা হয়)। লেচ এবং ফ্লিপ ফ্লপ উভয়ই ডেটা সংরক্ষণ করে, তবে লেচকে ফ্লিপ ফ্লপের চেয়ে সরল বা 'এসিনক্রোনাস' স্মৃতি উপাদান হিসেবে বিবেচনা করা হয়।"
    },
    {
      "id": 14,
      "name": "রেজিস্টার কি? প্রকারভেদ",
      "definition": "রেজিস্টার হলো ডিজিটাল ইলেকট্রনিক্সে ব্যবহৃত একটি **দ্রুত অ্যাক্সেসযোগ্য স্মৃতি উপাদান**, যা একাধিক ফ্লিপ ফ্লপের সমন্বয়ে গঠিত এবং একটি **শব্দ (Word) বা বাইনারি ডেটার গ্রুপকে** (যেমন: ৪ বিট, ৮ বিট বা ৬৪ বিট) সাময়িকভাবে ধরে রাখতে বা সংরক্ষণ করতে সক্ষম। এটি মাইক্রোপ্রসেসরের অভ্যন্তরে ডেটা, ইনস্ট্রাকশন বা মেমরি অ্যাড্রেস দ্রুত সংরক্ষণের জন্য ব্যবহৃত হয়। **প্রকারভেদ** প্রধানত ডেটা প্রবাহের ভিত্তিতে হয়: **১. প্যারালাল রেজিস্টার (Parallel Register)**, যা সমস্ত বিট একযোগে লোড করে; এবং **২. শিফট রেজিস্টার (Shift Register)**, যা ডেটাকে বিট বাই বিট ক্রমান্বয়ে স্থানান্তরিত করে।"
    },
    {
      "id": 15,
      "name": "কাউন্টার কি ?",
      "definition": "কাউন্টার (Counter) হলো এমন একটি সিকোয়েন্সিয়াল লজিক সার্কিট যা **ক্লক পালসের সংখ্যা গণনা** করার জন্য ডিজাইন করা হয়েছে। এটি মূলত ফ্লিপ ফ্লপ ব্যবহার করে তৈরি করা হয় এবং ক্লক পালস ইনপুটে আসার সাথে সাথে এর আউটপুট একটি নির্দিষ্ট বাইনারি ক্রমে পরিবর্তিত হতে থাকে। কাউন্টার ডিজিটাল সিস্টেমে সময় পরিমাপ, ফ্রিকোয়েন্সি বিভাগ (Frequency Division) এবং ক্রমানুসারে অপারেশন নিয়ন্ত্রণের জন্য ব্যবহৃত হয়। কাউন্টার প্রধানত **অ্যাসিনক্রোনাস (Ripple)** এবং **সিনক্রোনাস** এই দুই ধরনের হতে পারে।"
    },
    {
      "id": 16,
      "name": "বিভিন্ন ধরনের কাউন্টার",
      "definition": "কাউন্টারের প্রধান প্রকারভেদগুলো হলো: **১. অ্যাসিনক্রোনাস বা রিপল কাউন্টার (Asynchronous/Ripple Counter):** যেখানে একটি ফ্লিপ ফ্লপের আউটপুট পরবর্তী ফ্লিপ ফ্লপের ক্লক ইনপুট হিসেবে কাজ করে, যার ফলে গেটগুলোতে কিছুটা বিলম্ব হয়। **২. সিনক্রোনাস কাউন্টার (Synchronous Counter):** যেখানে সমস্ত ফ্লিপ ফ্লপ একই সাথে একটি সাধারণ ক্লক পালস দ্বারা নিয়ন্ত্রিত হয়, ফলে গেটিং বিলম্ব কম হয়। এছাড়াও রয়েছে: **৩. আপ কাউন্টার (Up Counter):** যা গণনা বাড়িয়ে চলে (যেমন: ০, ১, ২, ৩); **৪. ডাউন কাউন্টার (Down Counter):** যা গণনা কমিয়ে চলে (যেমন: ৩, ২, ১, ০); এবং **৫. আপ/ডাউন কাউন্টার (Up/Down Counter):** যা প্রয়োজন অনুযায়ী গণনা বাড়াতে বা কমাতে পারে।"
    }
  ]
}
